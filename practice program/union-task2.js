const data_fr = +prompt('Скільки елементів буде мати перша множина?');
let fr = [];

for(let d1 = 0; d1 < data_fr; d1++) {
    fr.push(+prompt('Введіть елемент першої множини'));
}
console.log('Перша множина складається з таких елементів: ' + fr);

const data_sc = +prompt('Скільки елементів буде мати друга множина?');
let sc = [];

for(let d2 = 0; d2 < data_sc; d2++) {
    sc.push(+prompt('Введіть елемент другої множини'));
}
console.log('Друга множина складається з таких елементів: ' + sc);

function inection(fr, sc) {
    // ін’єкція (всі ел. з 1-ї відповідають унікальному ел. в 2-й, в 2-й можуть залишитись ще вільні елементи):
    let kk = fr.length;

    console.log('Функція для даного ін\'єктивного відображення: y = x²');
    for (let coeff1 = 0; coeff1 < fr.length; coeff1++) {
        for (let coeff2 = 0; coeff2 < sc.length; coeff2++) {
            if (fr[coeff1] ** 2 === sc[coeff2]) {
                // тут задається умова для відображення, в даному випадку це квадрат
                console.log('Елемент 1ї множини: ', fr[coeff1], 'має відображення в 2й множини: ', sc[coeff2]);
                kk--;
                sc[coeff2] = 'used'; // деактивуємо ел. з другої множини цей елемент, щоб він не повторювався далі
            }
        }
    }

    if (kk === 0) {
        console.log('Властивість ін\'єкції виконана. Кожен елемент з першої множини має унікальне відображення в другій.');
    } else {
        console.log('Властивість ін\'єкції не виконана.');
    }
}

function surection(fr, sc) {
    // сюр\'єкція (всі ел. з 1-ї відповідають якомусь ел. в 2-й, в 2-й можуть залишитись ще вільні елементи):
    let j = fr.length;

    console.log('Функція для даного сюр\'єктивного відображення: y = x²');
    for (let coeff1 = 0; coeff1 < fr.length; coeff1++) {
        for (let coeff2 = 0; coeff2 < sc.length; coeff2++) {
            if (fr[coeff1] ** 2 === sc[coeff2]) {
                // тут задається умова для відображення, в даному випадку це квадрат
                console.log('Елемент 1ї множини: ', fr[coeff1], 'має відображення в 2й множини: ', sc[coeff2]);
                j--;
            }
        }
    }

    if (j === 0) {
        console.log('Властивість сюр\'єкції виконана. Кожен елемент з першої множини має відображення в другій.');
    } else {
        console.log('Властивість сюр\'єкції не виконана.');
    }
}

function biection(fr, sc) {
    // бієкція (тільки один відповідник):
    let bi = 0;
    if (sc.length !== fr.length) {
        console.log('Бієкція не може бути виконана, бо кількість елементів в двух множинах не є рівна, а це суперечіть бієкції. ')
    } else {
        console.log('Функція для даного бієктивного відображення: y = x²');
        for (let coeff1 = 0; coeff1 < fr.length; coeff1++) {
            for (let coeff2 = 0; coeff2 < sc.length; coeff2++) {
                if (fr[coeff1] ** 2 === sc[coeff2]) {
                    // тут задається умова для відображення, в даному випадку це квадрат
                    console.log('Елемент 1ї множини: ', fr[coeff1], 'має відображення в 2й множини: ', sc[coeff2]);
                    bi++;
                }
            }
        }

        if (bi === fr.length) {
            console.log('Властивість бієкції виконана. Кожен елемент з першої множини має тільке одне відображення в другій.');
        } else {
            console.log('Властивість бієкції не виконана.');
        }
    }
}

surection(fr, sc);
biection(fr, sc);
inection(fr, sc);